#include "../include/functions/copy.h"

/**
<% include doc.cc.ejs -%>
 */
<% if (functionInfo.isAsync) { -%>
class <%- functionInfo.cppFunctionName %>Worker : public NanAsyncWorker {
  public:
    <%- functionInfo.cppFunctionName %>Worker(NanCallback *callback
<%
for (var i = 0; i < functionInfo.args.length; i++) {
  var arg = functionInfo.args[i];
  if (!arg.isReturn) {
-%>
      , Local<Object> <%- arg.name %>Reference
<%
  }
}
-%>
    ) : NanAsyncWorker(callback), error_code(GIT_OK) {
<%
  for (var i = 0; i < functionInfo.args.length; i++) {
    var arg = functionInfo.args[i];
    if (!arg.isReturn) {
-%>
      SaveToPersistent("<%- arg.name %>", <%- arg.name %>Reference);
<%
    }
  }
-%>
    }
    ~<%- functionInfo.cppFunctionName %>Worker() {}

    void HandleOKCallback() {
      TryCatch try_catch;
      if(this->error_code == GIT_OK) {
<%
if (!returns.length) {
-%>
        callback->Call(0, NULL);
<%
} else {
    if (returns.length == 1) {
  var to = {}; to.__proto__ = returns[0]; to.name = "this->" + to.name;
-%>
      Handle<Value> to;
      <% include convertToV8.cc.ejs -%>
      Handle<Value> result = to;
<%
    } else {
-%>
      Handle<Object> result = NanNew<Object>();
      Handle<Value> to;
<%
      for (r in returns) {
        var to = returns[r];
-%>
    <% include convertToV8.cc.ejs -%>
    result->Set(NanSymbol("<%- to.jsName || to.name %>"), to);
<%
      }
-%>
    Handle<Value> argv[2] = {
      NanNew(NanNull()),
      result
    };
    callback->Call(2, argv);
<%
  }
-%>
  } else {
<%
    for (var i = 0; i < functionInfo.args.length; i++) {
      var arg = functionInfo.args[i];
      if (!arg.shouldAlloc) continue;
-%>
    free(this-><%= arg.name %> );
    <% } %>
  }

  if (try_catch.HasCaught()) {
    node::FatalException(try_catch);
  }
<%
    for (var i = 0; i < functionInfo.args.length; i++) {
      var arg = functionInfo.args[i];
      if (['String', 'Array'].indexOf(arg.cppClassName) > -1) {
        if (arg.freeFunctionName) {
-%>
    <%- arg.freeFunctionName %>(this-><%- arg.name %>);
<%
        } else {
-%>
  free((void *)this-><%- arg.name %>);<%
        }
      }
    }
-%>
  //delete baton;
      // normal callback...
      //NanScope();

      //Local<Value> argv[] = {
      //  NanNew(NanNull()),
      //  NanNewBufferHandle((char*)resultdata, resultsize)
      //};

      //callback->Call(2, argv);
    }

    void Execute() {
<%
  if (functionInfo.return.cType != "void" || functionInfo.return.isErrorCode) {
    // call git function
%>
      <%- functionInfo.return.cType %> result = <% } %><%- functionInfo.cFunctionName %>(<%
  // print args
    for (var i = 0; i < functionInfo.args.length; i++) {
      var arg = functionInfo.args[i];
      if (arg.isReturn && /\*\*/.test(arg.cType)) {
        %>&<%
      }
      %>this-><%- arg.name %><%
      if(i < functionInfo.args.length - 1) {
        %>, <%
      }
    } -%> );

<%
    if (functionInfo.return.isErrorCode) {
-%>
      this->error_code = result;
      const git_error* err;
      if (result != GIT_OK && (err = giterr_last()) != NULL) {
        SetErrorMessage(err->message);
      }
<%
    } else if (functionInfo.return.cType != "void") {
-%>
      this->result = result;
<%
    }
  // end: Execute
-%>
    }

  private:
<%
    for (var i = 0; i < functionInfo.args.length; i++) {
      var arg = functionInfo.args[i];
      if (arg.isReturn) {
-%>
    <%- arg.cType.replace('**', '*') %> <%- arg.name %>;
<%
      } else {
-%>
    <%- arg.cType %> <%- arg.name %>;
<%
      }
    }
-%>
    int error_code;
    //const git_error* error;
};

<%
  }
}
-%>


NAN_METHOD(<%- cppClassName %>::<%- functionInfo.cppFunctionName %>) {
  NanScope();
<% var jsArg; -%>
  <% include guardArguments.cc.ejs %>
  if (args.Length() == <%- jsArg %> || !args[<%- jsArg %>]->IsFunction()) {
    NanThrowError("Callback is required and must be a Function.");
  }
<%
    for (var cArg = 0, jsArg = 0; cArg < functionInfo.args.length; cArg++) {
      var arg = functionInfo.args[cArg];
      if (!arg.isReturn) {
        if (arg.isSelf) {
-%>
  //this-><%- arg.name %>Reference = Persistent<Value>::New(args.This());
  <%- cppClassName %>* <%- arg.name %> = ObjectWrap::Unwrap<<%- cppClassName %>>(args.This())->GetValue();
<%
        } else {
-%>
  //baton-><%- arg.name %>Reference = Persistent<Value>::New(args[<%- jsArg %>]);
  //convert: <% include convertFromV8.cc.ejs -%>
<%
          if(!arg.isPayload) {
-%>
  //baton-><%- arg.name %> = from_<%- arg.name %>;
<%
          }
        }
        if (!(arg.isReturn || arg.isSelf || arg.isPayload)) jsArg++;
      } else {
        if (arg.shouldAlloc) {
-%>
  this-><%- arg.name %> = (<%- arg.cType %>)malloc(sizeof(<%- arg.cType.replace('*', '') %>));
<%
        } else {
        }
      }
    } -%>
  NanCallback *callback = new NanCallback(args[<%- jsArg %>].As<v8::Function>());
  NanAsyncQueueWorker(new <%- functionInfo.cppFunctionName %>Worker(callback
<%
for (var i = 0; i < functionInfo.args.length; i++) {
  var arg = functionInfo.args[i];
  if (!arg.isReturn) {
-%>
      , <%- arg.name %>
<%
  }
}
-%>
  );

  NanReturnUndefined();
}
